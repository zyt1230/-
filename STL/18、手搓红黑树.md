 

一、了解
----

### 1、概念和性质

*   [红黑树](https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1001.2101.3001.7020)（Red-Black Tree）是一种自平衡的二叉搜索树
    
    *   通过对节点着色（红色/黑色）和旋转操作的约束
    *   时间复杂度为 **O(log n)**。
*   **平衡性质**：【重点】
    
    *   1、**节点颜色**：只有红和黑
    *   2、**根属性**：根节点必须是黑色。
    *   3、**叶子属性**：所有叶子节点（NULL，即空节点）为黑色。
    *   4、**红色约束**：红色节点的**子节点**必须为黑色（即**不可有连续的红色节点**）。
    *   5、**路径黑高** ：从任意节点到其所有后代叶子节点的路径中，黑色节点的数量（黑高）相同。

### 2、旋转操作

#### 2.1、左旋

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/af070cda86b445c7848fb4870e45eea5.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/69ccdf14ff394bcbad7fc75515e4798e.png)

```cpp

static void leftRotate(RBTree*tree,RBNode* x){
    RBNode* y = x->right;
    x->right=y->left;
    if(y->left){
        y->left->parent = x;
    }
    y->parent = x->parent;
    if(x->parent){
        if(x->parent->left==x){
            x->parent->left = y;
        }else{
            x->parent->right = y;
        }
    }else{
        tree->root = y;
    }
    y->left=x;
    x->parent= y;
}
```

#### 2.2、右旋

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/26e66f4ebd424ef9a493d9a67fa70431.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/968fa8f0361a486482a7747e47e1d175.png)

```cpp
static void rightRotate(RBTree*tree,RBNode* y){
    RBNode* x = y->left;
    y->left=x->right;
    if(x->right){
        x->right->parent = y;
    }
    x->parent = y->parent;
    if(y->parent){
        if(y->parent->left ==y){
            y->parent->left =x;
        }else{
            y->parent->right = x;
        }
    }else{
        tree->root=x;
    }
    x->right = y;
    y->parent = x;
}
```

### 3、插入操作

[推荐这个视频](https://www.bilibili.com/video/BV1Xm421x7Lg/?spm_id_from=333.337.search-card.all.click&vd_source=c6d25b8c148a15b1c45b8da5d613a042)

#### 3.1、第一种情况：叔叔是红色节点

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aa39a216c6f2465ca4260cea7ff3f17c.png)

> 步骤【x是插入的新节点】
> 
> *   1、父和叔叔设置为黑色
> *   2、祖父设置为红色
> *   3、插入新节点x改为祖父

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/402fd44805cd4f7ea1dddee7b1900454.png)

#### 3.2、第二种情况：叔叔是黑色节点

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a3f150b723554c5cba099a10781f9f7f.png)

##### 3.2.1、LL型

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/67448dd8c0ac4e71823a4f290d739434.png)

> 修改方法：  
> 1、右旋祖父节点g  
> 2、父母节点p、祖父节点g颜色交换。

##### 3.2.2、LR型

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9f7eea60157b48b7ac6741f50740c100.png)

> 修改方法：  
> 1、先左旋父母节点p  
> 2、重新标记x和p  
> 3、再按LL类型重复

##### 3.2.3、RR型

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/05b4ccfc2e9c4ce69003ddeb62a91e8e.png)

> 修改方法：  
> 1、先左旋祖父节点g  
> 2、交换g和p的颜色

##### 3.2.4、RL型

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/408c4acb89da4279b9a2ba6a48b024fe.png)

> 修改方法：  
> 1、右旋p  
> 2、重新标记x和p  
> 3、再按RR类型重复

##### 3.2.5、总结

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2ed8e4d5c4e240ee87cb342c03acdd04.png)

### 4、删除操作【复杂】

[推荐这个视频](https://www.bilibili.com/video/BV16m421u7Tb/?spm_id_from=333.788.player.switch&vd_source=8d33aa4d885c0eaadd82054a940a2630)

#### 4.1、了解删除过程

*   在一般的二叉树的删除操作中
    *   我们最终都是**删除一个叶子节点或只有一个孩子的情况**。（对于内部节点，就是要删除节点左右孩子都存在的情况，最终都会退化到删除节点是叶子节点或者是只有一个孩子的情况。）

> **注意**：  
> 即使是左右2个孩子的情况，也会退化到1个孩子或者叶子节点的情况。

#### 4.2、要删除节点的左或右孩子存在的情况（度为1）

*   有左孩子或右孩子的情况（**这里的孩子节点不是叶子节点**）。且**左孩子或右孩子为红色**。
    
    *   需要**将待删除节点和孩子节点相互代替并变黑**。
    
    > 注意：  
    > 如果左或右孩子不为红色，就容易导致黑路同性质被破坏。
    

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6b31956b9a184b3fb0e539094f56eee9.png)

#### 4.3、没有节点（度为0）

##### 4.3.1、待删除节点是红色

*   **直接删除**

##### 4.3.2、待删除节点是黑色【重点是看兄弟】

> *   引入**双黑节点的概念**
> *   顾名思义：就是一个节点是双重的，并且每一层都是黑色。
> *   双黑节点： 假设要删除节点y，那它叶子节点x变为双黑节点。双黑节点就是将有2个黑色节点重合在一起，看起来像双黑。并且这2个节点都指向同一方向。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/59415e2889024d6190d4c93e384acbd5.png)

###### 4.3.2.1、待删除节点的兄弟是红色

*   如果兄弟为红色，**父兄变色，朝双黑旋转。兄弟变黑，父亲变红。对父亲旋转**。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/38f0cdf1477b41d5b9d53a066324ccea.png)

> **注意**  
> 旋转后，双黑的兄弟是改变了的。图中没有表出来。实际上的兄弟是17了，不是15了。

###### 4.3.2.2、待删除节点的兄弟是黑色

*   第一种：[兄弟节点](https://so.csdn.net/so/search?q=%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020)的**孩子至少有一个是红色**
    
    *   先变色再LL、LR、RR、RL旋转
*   LL型  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/92ec6c4031554380b49ea97a06b11029.png)  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/951e4bf183f34302896df5e58ca03ec4.png)  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b258c2eacf954737a927a90239946155.png)
    

> 删除节点25后，25的位置变双黑节点  
> r变w，w变p，p变黑色，p右旋  
> 再变单黑

*   LR型  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b0195d5b0b49478aadb74ad95246ef20.png)  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3145fc1ba4b84dc9ad684cb770fb0a86.png)

> 删除节点变双黑  
> r 变 p ，w变红，p 变黑  
> 左旋w ，右旋p  
> 再变单黑

*   RR型  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/410eac2b3bc9423ca9c9255dd4723c92.png)  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b58865995b00409188bd21e843c82797.png)

> 删除节点2后，2的位置变双黑节点  
> r变w，w变p，p变黑色，p右旋  
> 再变单黑

*   RL型  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/55464a7613ab49be9f9e85a91139fb6a.png)  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dc2d9bb703304bb495194f32b19b24ee.png)

> 删除节点变双黑  
> r 变 p ，w变红，p 变黑  
> 右旋w ，左旋p  
> 再变单黑

* * *

*   第二种：兄弟节点的**孩子都是黑色**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/85073bbbb8eb4c74aca6326d970b5c1a.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a7f44ef01898408bb5d44e19d0340825.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b90500fec263418a871375b94fa7ce63.png)

> 删除9 ，变为双黑节点  
> **兄弟变红，双黑上移**，继续修复双黑节点。

二、代码实现过程（c语言和cpp语言）【最好都自己实现】
----------------------------

### 1、c语言

#### 1.1、左旋操作

```cpp
static void leftRotate(RBTree*tree,RBNode* x){
    RBNode* y = x->right;
    x->right=y->left;
    if(y->left){
        y->left->parent = x;
    }
    y->parent = x->parent;
    if(x->parent){
        if(x->parent->left==x){
            x->parent->left = y;
        }else{
            x->parent->right = y;
        }
    }else{
        tree->root = y;
    }
    y->left=x;
    x->parent= y;
}
```

#### 1.2、右旋操作

```cpp
static void rightRotate(RBTree*tree,RBNode* y){
    RBNode* x = y->left;
    y->left=x->right;
    if(x->right){
        x->right->parent = y;
    }
    x->parent = y->parent;
    if(y->parent){
        if(y->parent->left ==y){
            y->parent->left =x;
        }else{
            y->parent->right = x;
        }
    }else{
        tree->root=x;
    }
    x->right = y;
    y->parent = x;
}
```

#### 1.3、打印操作

*   \-1 表示左孩子，1 表示右孩子
*   0 表示根节点

```cpp
void printRBNode(RBNode *node, int p_key, int dir) {
    if (!node) return;
    const char *dir_str[] = { "root", "right child", "left child" };
    printf("%2d[%c] is %s\n", node->key, (node->color == RED) ? 'R' : 'B', 
           dir_str[dir + 1]);
    printRBNode(node->left, node->key, -1);
    printRBNode(node->right, node->key, 1);
}
```

#### 1.4、插入操作及其修改插入

```cpp
static void insertFixUp(RBTree* tree,RBNode* node){
    RBNode* parent=node->parent;
    RBNode* uncle;
    RBNode* tmp;
    RBNode* grandParent;
    
    while(parent&&parent->color==RED){
        //找到祖父节点，确定叔叔节点
        grandParent=parent->parent;
        if(grandParent->left==parent){
            uncle = grandParent->right;
        }else{
            uncle = grandParent->left;
        }
        if(uncle&&uncle->color==RED){
            uncle->color=BLACK;
            parent->color=BLACK;
            grandParent->color = RED;
            node = grandParent;
            parent = node->parent;
            continue;
        }
        if(grandParent->left==parent){//L
            if(parent->right==node){//R
                leftRotate(tree, parent);
                tmp = parent;
                parent = node;
                node = tmp;//交换node和parent
            }
            //L
            rightRotate(tree,grandParent);
            grandParent->color=RED;
            parent->color=BLACK;
        }else{//R
            if(parent->left==node){//L
                rightRotate(tree, parent);
                tmp = parent;
                parent = node;
                node=tmp;
            }
            //R
            leftRotate(tree, grandParent);
            grandParent->color=RED;
            parent->color = BLACK;
        }
    }
    tree->root->color = BLACK;//根节点为黑色
}
void insertRBTree(RBTree*tree ,KeyType key){
    //1、创建一个红色节点
    RBNode* node = createRBNode(key);
    //2、根据二叉树的规则找到待插入的位置
    RBNode* cur = tree->root;
    RBNode* pre = nullptr;
    while(cur){
        pre = cur;
        if(key<cur->key){
            cur = cur->left;
        }else if(key>cur->key){
            cur = cur->right;
        }else{
            printf("key:%d have exits\n",key);
            free(node);
            return ;
        }
    }
    //3、在对应的位置进行插入,若是root节点，更新tree
    node->parent = pre;
    if(pre){
        if(key<pre->key){
            pre->left = node;
        }else{
            pre->right = node;
        }
    }else{
        //树为空的情况
        tree->root = node;
    }
    tree->count++;
    //4、修复红黑树的性质(红红节点)
    insertFixUp(tree,node);
}
```

#### 1.5、删除操作及其修改

```cpp
static void deleteFixUp(RBTree* tree,RBNode*x,RBNode* parent){
    //1、先找兄弟
    RBNode* w;//w是兄弟
    while(tree->root!=x&&(!x||x->color==BLACK)){
        //x为单黑,x是根节点的时候停下来
        if(parent->left==x){//确定兄弟的位置
            w=parent->right;//双黑在左边
            if(w->color==RED){//case 1,兄弟节点是红色
                
                //父兄变色，父亲朝双黑旋转
                w->color=BLACK;//兄弟变黑
                parent->color=RED;//父亲变红
                leftRotate(tree, parent);
                w=parent->right;//w的位置改变
            
            }
            if((!w->left||w->left->color==BLACK)&&
                (!w->right||w->right->color==BLACK))
            {
//(!w->right||w->right->color==BLACK)是指：要么是空节点，要么有一个节点为黑色。
//这里的if指2个孩子节点都是黑色。
                    //兄弟变红，双黑上移
                    w->color = RED;
                    x= parent;
                    parent=x->parent;
            }else{//2个孩子里有一个是红色,或者2个为红色
                if(!w->right||w->right->color==BLACK){//w左孩子是红色
                    w->left->color=BLACK;
                    w->color=RED;
                    rightRotate(tree,w);
                    w= parent->right;
                }
                w->color=parent->color;
                parent->color= BLACK;
                w->right->color=BLACK;
                leftRotate(tree, parent);
                x=tree->root;//变单黑了，退出程序
            }

        }else{
            w=parent->left;//兄弟在左边，双黑在右边
            if(w->color==RED){
                w->color=BLACK;
                parent->color=RED;
                rightRotate(tree,parent);
                w=parent->left;
            }
            if((!w->left||w->left->color==BLACK)
            &&(!w->right||w->right->color==BLACK))
            {
                //兄弟是黑色，w的2个孩子也是黑色
                w->color=RED;
                x=parent;
                parent=x->parent;
            }else{//w至少有一个孩子是红色
                if(!w->left||w->left->color==BLACK){
                    //LR
                    w->right->color = BLACK;
                    w->color=RED;
                    leftRotate(tree, w);
                    w=parent->left;
                }
                //LL
                w->color=parent->color;
                parent->color=BLACK;
                w->left->color=BLACK;
                rightRotate(tree, parent);
                x= tree->root;//变单黑了，退出程序
            }

        }
    }
    //全部完成时，x可能是红色
    if(x){
        x->color=BLACK;
    }
}
static void deleteRBNode(RBTree* tree,RBNode* node){
    RBNode* x;//替换节点
    RBNode* y;//真正删除节点
    RBNode* parent;//y的父亲
    if(node->left==NULL||node->right==NULL){
        y= node;//度为1或0
    }else{
        y=node->right;
        while(y->left){
            y=y->left;//用右子树的左边最小的节点
        }
    }
    //真正删除节点找到了，开始找替换节点
    if(y->left){
        x=y->left;
    }else{
        x=y->right;
    }
    parent = y->parent;
    //开始更新替换节点和原父节点的关系
    if(x){//删除y
        x->parent = parent;
    }
    if(y->parent==NULL){
        //说明是根节点
        tree->root = x;
    }else if(y->parent->left==y){
        y->parent->left = x;
    }else if(y->parent->right==y){
        y->parent->right= x;
    }
    //3、度为2的点要交换值
    if(y!=node){
        node->key=y->key;
    }
    //4、如果删除的点是黑色
    //需要调整
    if(y->color==BLACK){
        deleteFixUp(tree,x,parent);//传入双黑节点
    }
    free(y);
}

//删除操作
void deleteRBTree(RBTree* tree ,KeyType key){
    //1、查找key所在的节点
    RBNode* node = searchRBTree(tree,key);
    //2、删除key的结点
    if(node){
        deleteRBNode(tree,node);
    }
    
}
```

### 2、cpp语言

#### 2.1、定义和初始化操作

*   节点

```cpp
class Node{
        public:
            KeyType key;
            Value value;
            Color color;
            Node* left;
            Node* right;
            Node* parent;
            //构造函数
            //1、拷贝构造
            Node(const KeyType&k,const Value& v,Color&c,Node* p=nullptr):
            key(k),value(v),color(c),left(nullptr),right(nullptr),parent(p){
        
            }
            //2、默认
            Node(): 
            color(Color::BLACK), 
            left(nullptr), 
            right(nullptr), 
            parent(nullptr) {

            }
            
    };
```

*   根节点

```cpp
private:
    Node* root;//根节点
    size_t size;//红黑树的节点个数
    Node* Nil;//叶子节点
```

#### 2.2、插入操作

```cpp
    //---------------6、插入的修改操作
    void insertFixup(Node* target){
        //定义叔叔节点
        Node* uncle;
        //当目标节点的父节点存在且父节点为红色时,进行修复
        while(target->parent&& target->parent->color==Color::RED){
            //开始确定叔叔节点位置
            // 当目标节点的父节点是祖父节点的左子节点时
            if(target->parent == target->parent->parent->left){
                uncle=target->parent->parent->right;
                if(uncle&&uncle->color==Color::RED){
                    // 如果叔叔节点存在且为红色，进行颜色调整
                    target->parent->color=Color::BLACK;// 父节点设为黑色
                    target->parent->parent->color=Color::RED;// 祖父节点设为红色
                    uncle->color=Color::BLACK;// 叔叔节点设为黑色
                    target = target->parent->parent;// 将祖父节点设为下一个目标节点
                }else{//叔叔节点是黑色的时候（叶子节点也是黑色）
                    //如果目标节点是父节点的右子节点，进行左旋转
                    if (target == target->parent->right){
                        target = target->parent; // 更新目标节点为父节点
                        leftRotate(target);      // 对目标节点进行左旋
                    }
                    // 调整父节点和祖父节点的颜色，并进行右旋转
                    target->parent->color = Color::BLACK;
                    target->parent->parent->color = Color::RED;
                    rightRotate(target->parent->parent);
                }
            }else{//叔叔节点是左边
                // 当目标节点的父节点是祖父节点的右子节点时，与上面对称
                Node *uncle = target->parent->parent->left; // 叔叔节点
                if(uncle&&uncle->color==Color::RED){
                    target->parent->color=Color::BLACK;
                    target->parent->color = Color::BLACK;
                    target->parent->parent->color = Color::RED;
                    target = target->parent->parent;
                }else{//叔叔节点是黑色or 叔叔节点是空节点   
                    if(target==target->parent->left){
                        target = target->parent;
                        leftRotate(target);
                    }
                    //调整父节点和祖父节点的颜色，并进行左旋转
                    target->parent->color==Color::BLACK;
                    target->parent->parent->color = Color::RED;
                    leftRotate(target->parent->parent);
                }
            }
        }
        //确保根节点为黑色
        root->color=Color::BLACK;
    }
    //------------------7、插入节点函数
    void insertNode(const KeyType& key,const Value& value){
        //
        Node* newNode = new Node(key,value,Color::RED);
        Node* parent = nullptr;//新节点的父节点指针
        Node* cur = root;//初始当前节点为根节点
        Node* pre = nullptr;
        while(cur){
            pre = cur;
            if(newNode->key<cur->key){
                cur=cur->left;
            }else if(newNode->key>cur->key){
                cur=cur->right;
            }else{
                delete newNode;
                return;
            }
        }
        //pre就是要插入节点的父节点位置
        parent = pre;
        newNode->parent = parent;
        //个数加1
        size++;
        if(!parent){
            root=newNode;
        }else if(newNode->key<parent->key){
            parent->left=newNode;
            // 如果新节点的键小于父节点的键，将新节点插入父节点的左子树

        }else{
            parent->right=newNode;// 否则，将新节点插入父节点的右子树
        }
        //插入新节点后，调用insertFixup函数来修复可能破坏的红黑树性质
        insertFixup(newNode);
    }
```

#### 2.3、删除操作

*   Nil作用
    *   就是把所有叶子节点都指向 Nil，而非 NULL，避免了在操作中意外访问非法内存。
    *   按照c语言的写，把空节点改为Nil ，最后取消连接Nil 。

```cpp
// 辅助函数，用新节点替换旧节点
  
  void replaceNode(Node *targetNode, Node *newNode) {
    if (!targetNode->parent) {
      root = newNode;
    } else if (targetNode == targetNode->parent->left) {
      targetNode->parent->left = newNode;
    } else {
      targetNode->parent->right = newNode;
    }
    if (newNode) {
      newNode->parent = targetNode->parent;
    }
  }

  // 寻找以某个节点为根节点的子树中的最小节点
  Node *findMinimumNode(Node *node) {
    while (node->left) {
      node = node->left;
    }
    return node;
  }

  // removeFixup函数用于在删除节点后恢复红黑树的性质
  void removeFixup(Node *node) {
    // 如果节点为Nil并且没有父节点，说明它是唯一的节点，直接返回
    if (node == Nil && node->parent == nullptr) {
      return;
    }

    // 当我们没有到达根节点时继续循环
    while (node != root) {
      // 如果节点是其父节点的左子节点
      if (node == node->parent->left) {
        // 兄弟节点是节点父亲的右子节点
        Node *sibling = node->parent->right;

        // 情况1：节点的兄弟节点是红色
        if (getColor(sibling) == Color::RED) {
          // 重新着色兄弟节点和父节点，并进行左旋
          setColor(sibling, Color::BLACK);
          setColor(node->parent, Color::RED);
          leftRotate(node->parent);
          // 旋转后更新兄弟节点
          sibling = node->parent->right;
        }

        // 情况2：兄弟节点的两个子节点都是黑色
        if (getColor(sibling->left) == Color::BLACK &&
            getColor(sibling->right) == Color::BLACK) {
          // 重新着色兄弟节点并向上移动
          setColor(sibling, Color::RED);
          node = node->parent;
          // 如果父节点是红色，将其改为黑色并结束
          if (node->color == Color::RED) {
            node->color = Color::BLACK;
            node = root;
          }
        } else {
          // 情况3：兄弟节点的右子节点是黑色（左子节点是红色）
          if (getColor(sibling->right) == Color::BLACK) {
            // 重新着色兄弟节点和兄弟节点的左子节点，并进行右旋
            setColor(sibling->left, Color::BLACK);
            setColor(sibling, Color::RED);
            rightRotate(sibling);
            // 旋转后更新兄弟节点
            sibling = node->parent->right;
          }

          // 情况4：兄弟节点的右子节点是红色
          setColor(sibling, getColor(node->parent));
          setColor(node->parent, Color::BLACK);
          setColor(sibling->right, Color::BLACK);
          leftRotate(node->parent);
          // 移动到根节点结束
          node = root;
        }
      } else {
        // 当节点是其父节点的右子节点时，对称的情况
        Node *sibling = node->parent->left;

        if (getColor(sibling) == Color::RED) {
          setColor(sibling, Color::BLACK);
          setColor(node->parent, Color::RED);
          rightRotate(node->parent);
          sibling = node->parent->left;
        }

        if (getColor(sibling->right) == Color::BLACK &&
            getColor(sibling->left) == Color::BLACK) {
          setColor(sibling, Color::RED);
          node = node->parent;
          if (node->color == Color::RED) {
            node->color = Color::BLACK;
            node = root;
          }
        } else {
          if (getColor(sibling->left) == Color::BLACK) {
            setColor(sibling->right, Color::BLACK);
            setColor(sibling, Color::RED);
            leftRotate(sibling);
            sibling = node->parent->left;
          }
          setColor(sibling, getColor(node->parent));
          setColor(node->parent, Color::BLACK);
          setColor(sibling->left, Color::BLACK);
          rightRotate(node->parent);
          node = root;
        }
      }
    }
    // 确保当前节点是黑色的，以维持红黑树性质
    setColor(node, Color::BLACK);
  }

  // 获取颜色, 空指针为黑色
  Color getColor(Node *node) {
    if (node == nullptr) {
      return Color::BLACK;
    }
    return node->color;
  }

  void setColor(Node *node, Color color) {
    if (node == nullptr) {
      return;
    }
    node->color = color;
  }

  // 取消Nil哨兵的连接
  void dieConnectNil() {
    if (Nil == nullptr) {
      return;
    }
    if (Nil->parent != nullptr) {
      if (Nil == Nil->parent->left) {
        Nil->parent->left = nullptr;
      } else {
        Nil->parent->right = nullptr;
      }
    }
  }

  // 删除节点
  void deleteNode(Node *del) {
    Node *nodeToDelete = del;
    Node *child = nullptr;
    Node *fixupNode = nullptr;
    Color originalColor = nodeToDelete->color;

    // Case 1: Node has no left child
    if (del->left == nullptr) {
        child = del->right;
        fixupNode = child;
        replaceNode(del, child);
    } 
    // Case 2: Node has no right child
    else if (del->right == nullptr) {
        child = del->left;
        fixupNode = child;
        replaceNode(del, child);
    } 
    // Case 3: Node has two children
    else {
        // Find minimum node in right subtree (successor)
        nodeToDelete = findMinimumNode(del->right);
        originalColor = nodeToDelete->color;
        child = nodeToDelete->right;
        fixupNode = child;

        if (nodeToDelete->parent == del) {
            if (child != nullptr) {
                child->parent = nodeToDelete;
            }
        } else {
            replaceNode(nodeToDelete, child);
            nodeToDelete->right = del->right;
            nodeToDelete->right->parent = nodeToDelete;
        }

        replaceNode(del, nodeToDelete);
        nodeToDelete->left = del->left;
        nodeToDelete->left->parent = nodeToDelete;
        nodeToDelete->color = del->color;
    }

    // If the deleted node was black, fix the tree
    if (originalColor == Color::BLACK) {
        if (fixupNode == nullptr) {
            // Use Nil as temporary node
            Nil->parent = del->parent;
            fixupNode = Nil;
            removeFixup(fixupNode);
            dieConnectNil();
        } else {
            removeFixup(fixupNode);
        }
    }

    delete del;
}

```

#### 2.4、打印操作

```cpp
    void inorderTravel(Node* node)const{
        if(node){
            inorderTravel(node->left);
            cout<<node->key<<" "<<node->value<<endl;
            inorderTravel(node->right);
        }
    }
```

#### 2.5、获取大小

```cpp
    //size大小
    int getSize(){return size;};
```

#### 2.6、查询某节点

```cpp
    //-----------------3、查询节点
private:
    Node* lookUp(KeyType key){
        Node* cur = root;
        while(cur){
            //判断要找的节点是在当前节点的左还是右
            if(key<cur->key){
                cur= cur->left;
            }else if(key>cur->key){
                cur=cur->right;
            }else{//找到节点
                return cur;
            }
        }
        //没找到节点
        return NULL;
    }
```

#### 2.7、左旋操作

```cpp
    //---------------4、左旋
    void leftRotate(Node *node) {
        Node *r_son = node->right;
    
        node->right = r_son->left;
    
        if (r_son->left) {
          r_son->left->parent = node;
        }
    
        r_son->parent = node->parent;
        if (!node->parent) {
          root = r_son;
        } else if (node == node->parent->left) {
          node->parent->left = r_son;
        } else {
          node->parent->right = r_son;
        }
    
        r_son->left = node;
        node->parent = r_son;
    }
```

#### 2.8、右旋操作

```cpp
    //---------------5、右旋
    void rightRotate(Node *node) 
    {
        Node *l_son = node->left; // 获取当前节点的左子节点
    
        // 当前节点的左子树变成左子节点的右子树
        node->left = l_son->right;
        // 如果左子节点的右子树非空，更新其父指针
        if (l_son->right) {
          l_son->right->parent = node;
        }
    
        // 左子节点升为当前节点位置，并处理父节点关系
        l_son->parent = node->parent;
        // 如果当前节点是根节点，更新根节点为左子节点
        if (!node->parent) {
          root = l_son;
          // 如果当前节点是其父节点的左子节点，更新父节点的左子节点为左子节点
        } else if (node == node->parent->left) {
          node->parent->left = l_son;
          // 如果当前节点是其父节点的右子节点，更新父节点的右子节点为左子节点
        } else {
          node->parent->right = l_son;
        }
    
        // 完成右旋转，将当前节点成为左子节点的右子节点
        l_son->right = node;
        // 更新当前节点的父节点为左子节点
        node->parent = l_son;
    }
```

#### 2.9、完整cpp代码

```cpp
#include <iostream>
#include <sstream>
#include <string>

enum class Color { RED, BLACK };

template <typename Key, typename Value> 
class RedBlackTree {
  class Node {
  public:
    Key key;
    Value value;
    Color color;
    Node *left;
    Node *right;
    Node *parent;

    // 构造函数
    Node(const Key &k, const Value &v, Color c, Node *p = nullptr)
        : key(k), value(v), color(c), left(nullptr), right(nullptr), parent(p) {
    }
    Node()
        : color(Color::BLACK), left(nullptr), right(nullptr), parent(nullptr) {}
  };

private:
  Node *root;
  size_t size;
  Node *Nil;

  // 查询某节点
  Node *lookUp(Key key) {
    Node *cmpNode = root;

    while (cmpNode) {
      if (key < cmpNode->key) {
        cmpNode = cmpNode->left;
      } else if (key > cmpNode->key) {
        cmpNode = cmpNode->right;
      } else {
        return cmpNode;
      }
    }
    return cmpNode;
  }

  // 右旋函数
  void rightRotate(Node *node) {
    Node *l_son = node->left; // 获取当前节点的左子节点

    // 当前节点的左子树变成左子节点的右子树
    node->left = l_son->right;
    // 如果左子节点的右子树非空，更新其父指针
    if (l_son->right) {
      l_son->right->parent = node;
    }

    // 左子节点升为当前节点位置，并处理父节点关系
    l_son->parent = node->parent;
    // 如果当前节点是根节点，更新根节点为左子节点
    if (!node->parent) {
      root = l_son;
      // 如果当前节点是其父节点的左子节点，更新父节点的左子节点为左子节点
    } else if (node == node->parent->left) {
      node->parent->left = l_son;
      // 如果当前节点是其父节点的右子节点，更新父节点的右子节点为左子节点
    } else {
      node->parent->right = l_son;
    }

    // 完成右旋转，将当前节点成为左子节点的右子节点
    l_son->right = node;
    // 更新当前节点的父节点为左子节点
    node->parent = l_son;
  }

  // 左旋
  // 是右旋的对称情况, 逻辑和右旋是一样的
  void leftRotate(Node *node) {
    Node *r_son = node->right;

    node->right = r_son->left;

    if (r_son->left) {
      r_son->left->parent = node;
    }

    r_son->parent = node->parent;
    if (!node->parent) {
      root = r_son;
    } else if (node == node->parent->left) {
      node->parent->left = r_son;
    } else {
      node->parent->right = r_son;
    }

    r_son->left = node;
    node->parent = r_son;
  }

  // 插入修复函数
  void insertFixup(Node *target) {
    // 当目标节点的父节点存在且父节点的颜色是红色时，需要修复
    while (target->parent && target->parent->color == Color::RED) {
      // 当目标节点的父节点是祖父节点的左子节点时
      if (target->parent == target->parent->parent->left) {
        Node *uncle = target->parent->parent->right; // 叔叔节点
        // 如果叔叔节点存在且为红色，进行颜色调整
        if (uncle && uncle->color == Color::RED) {
          target->parent->color = Color::BLACK; // 父节点设为黑色
          uncle->color = Color::BLACK;          // 叔叔节点设为黑色
          target->parent->parent->color = Color::RED; // 祖父节点设为红色
          target = target->parent->parent; // 将祖父节点设为下一个目标节点
        } else {
          // 如果目标节点是父节点的右子节点，进行左旋转
          if (target == target->parent->right) {
            target = target->parent; // 更新目标节点为父节点
            leftRotate(target);      // 对目标节点进行左旋
          }
          // 调整父节点和祖父节点的颜色，并进行右旋转
          target->parent->color = Color::BLACK;
          target->parent->parent->color = Color::RED;
          rightRotate(target->parent->parent);
        }
      } else {
        // 当目标节点的父节点是祖父节点的右子节点时，与上面对称
        Node *uncle = target->parent->parent->left; // 叔叔节点
        if (uncle && uncle->color == Color::RED) {
          target->parent->color = Color::BLACK;
          uncle->color = Color::BLACK;
          target->parent->parent->color = Color::RED;
          target = target->parent->parent;
        } else {
          if (target == target->parent->left) {
            target = target->parent; // 更新目标节点为父节点
            rightRotate(target);     // 对目标节点进行右旋
          }
          // 调整父节点和祖父节点的颜色，并进行左旋转
          target->parent->color = Color::BLACK;
          target->parent->parent->color = Color::RED;
          leftRotate(target->parent->parent);
        }
      }
    }
    // 确保根节点始终为黑色
    root->color = Color::BLACK;
  }

  // 插入节点函数
  void insertNode(const Key &key, const Value &value) {
    // 创建一个新节点，节点的颜色初始化为红色
    Node *newNode = new Node(key, value, Color::RED);
    Node *parent = nullptr; // 新节点的父节点指针
    Node *cmpNode = root;   // 用于比较的节点，初始为根节点

    // 遍历树，找到新节点的正确位置
    while (cmpNode) {
      parent = cmpNode; // 保留当前节点作为新节点的潜在父节点
      // 如果新节点的键小于当前比较节点的键，则向左子树移动
      if (newNode->key < cmpNode->key) {
        cmpNode = cmpNode->left;
        // 如果新节点的键大于当前比较节点的键，则向右子树移动
      } else if (newNode->key > cmpNode->key) {
        cmpNode = cmpNode->right;
        // 如果键相等，则说明树中已有相同键的节点，删除新节点并返回
      } else {
        delete newNode;
        return;
      }
    }

    // 树的大小增加
    size++;

    // 将新节点的父节点设置为找到的父节点位置
    newNode->parent = parent;
    // 如果父节点为空，说明树是空的，新节点成为根节点
    if (!parent) {
      root = newNode;
      // 如果新节点的键小于父节点的键，将新节点插入父节点的左子树
    } else if (newNode->key < parent->key) {
      parent->left = newNode;
      // 否则，将新节点插入父节点的右子树
    } else {
      parent->right = newNode;
    }

    // 插入新节点后，调用insertFixup函数来修复可能破坏的红黑树性质
    insertFixup(newNode);
  }

  // 中序遍历
  void inorderTraversal(Node *node) const {
    if (node) {
      inorderTraversal(node->left);
      std::cout << node->key << " ";
      std::cout << node->value << " ";
      inorderTraversal(node->right);
    }
  }
  // 辅助函数，用新节点替换旧节点
  
  void replaceNode(Node *targetNode, Node *newNode) {
    if (!targetNode->parent) {
      root = newNode;
    } else if (targetNode == targetNode->parent->left) {
      targetNode->parent->left = newNode;
    } else {
      targetNode->parent->right = newNode;
    }
    if (newNode) {
      newNode->parent = targetNode->parent;
    }
  }

  // 寻找以某个节点为根节点的子树中的最小节点
  Node *findMinimumNode(Node *node) {
    while (node->left) {
      node = node->left;
    }
    return node;
  }

  // removeFixup函数用于在删除节点后恢复红黑树的性质
  void removeFixup(Node *node) {
    // 如果节点为Nil并且没有父节点，说明它是唯一的节点，直接返回
    if (node == Nil && node->parent == nullptr) {
      return;
    }

    // 当我们没有到达根节点时继续循环
    while (node != root) {
      // 如果节点是其父节点的左子节点
      if (node == node->parent->left) {
        // 兄弟节点是节点父亲的右子节点
        Node *sibling = node->parent->right;

        // 情况1：节点的兄弟节点是红色
        if (getColor(sibling) == Color::RED) {
          // 重新着色兄弟节点和父节点，并进行左旋
          setColor(sibling, Color::BLACK);
          setColor(node->parent, Color::RED);
          leftRotate(node->parent);
          // 旋转后更新兄弟节点
          sibling = node->parent->right;
        }

        // 情况2：兄弟节点的两个子节点都是黑色
        if (getColor(sibling->left) == Color::BLACK &&
            getColor(sibling->right) == Color::BLACK) {
          // 重新着色兄弟节点并向上移动
          setColor(sibling, Color::RED);
          node = node->parent;
          // 如果父节点是红色，将其改为黑色并结束
          if (node->color == Color::RED) {
            node->color = Color::BLACK;
            node = root;
          }
        } else {
          // 情况3：兄弟节点的右子节点是黑色（左子节点是红色）
          if (getColor(sibling->right) == Color::BLACK) {
            // 重新着色兄弟节点和兄弟节点的左子节点，并进行右旋
            setColor(sibling->left, Color::BLACK);
            setColor(sibling, Color::RED);
            rightRotate(sibling);
            // 旋转后更新兄弟节点
            sibling = node->parent->right;
          }

          // 情况4：兄弟节点的右子节点是红色
          setColor(sibling, getColor(node->parent));
          setColor(node->parent, Color::BLACK);
          setColor(sibling->right, Color::BLACK);
          leftRotate(node->parent);
          // 移动到根节点结束
          node = root;
        }
      } else {
        // 当节点是其父节点的右子节点时，对称的情况
        Node *sibling = node->parent->left;

        if (getColor(sibling) == Color::RED) {
          setColor(sibling, Color::BLACK);
          setColor(node->parent, Color::RED);
          rightRotate(node->parent);
          sibling = node->parent->left;
        }

        if (getColor(sibling->right) == Color::BLACK &&
            getColor(sibling->left) == Color::BLACK) {
          setColor(sibling, Color::RED);
          node = node->parent;
          if (node->color == Color::RED) {
            node->color = Color::BLACK;
            node = root;
          }
        } else {
          if (getColor(sibling->left) == Color::BLACK) {
            setColor(sibling->right, Color::BLACK);
            setColor(sibling, Color::RED);
            leftRotate(sibling);
            sibling = node->parent->left;
          }
          setColor(sibling, getColor(node->parent));
          setColor(node->parent, Color::BLACK);
          setColor(sibling->left, Color::BLACK);
          rightRotate(node->parent);
          node = root;
        }
      }
    }
    // 确保当前节点是黑色的，以维持红黑树性质
    setColor(node, Color::BLACK);
  }

  // 获取颜色, 空指针为黑色
  Color getColor(Node *node) {
    if (node == nullptr) {
      return Color::BLACK;
    }
    return node->color;
  }

  void setColor(Node *node, Color color) {
    if (node == nullptr) {
      return;
    }
    node->color = color;
  }

  // 取消Nil哨兵的连接
  void dieConnectNil() {
    if (Nil == nullptr) {
      return;
    }
    if (Nil->parent != nullptr) {
      if (Nil == Nil->parent->left) {
        Nil->parent->left = nullptr;
      } else {
        Nil->parent->right = nullptr;
      }
    }
  }

  // 删除节点
  void deleteNode(Node *del) {
    Node *nodeToDelete = del;
    Node *child = nullptr;
    Node *fixupNode = nullptr;
    Color originalColor = nodeToDelete->color;

    // Case 1: Node has no left child
    if (del->left == nullptr) {
        child = del->right;
        fixupNode = child;
        replaceNode(del, child);
    } 
    // Case 2: Node has no right child
    else if (del->right == nullptr) {
        child = del->left;
        fixupNode = child;
        replaceNode(del, child);
    } 
    // Case 3: Node has two children
    else {
        // Find minimum node in right subtree (successor)
        nodeToDelete = findMinimumNode(del->right);
        originalColor = nodeToDelete->color;
        child = nodeToDelete->right;
        fixupNode = child;

        if (nodeToDelete->parent == del) {
            if (child != nullptr) {
                child->parent = nodeToDelete;
            }
        } else {
            replaceNode(nodeToDelete, child);
            nodeToDelete->right = del->right;
            nodeToDelete->right->parent = nodeToDelete;
        }

        replaceNode(del, nodeToDelete);
        nodeToDelete->left = del->left;
        nodeToDelete->left->parent = nodeToDelete;
        nodeToDelete->color = del->color;
    }

    // If the deleted node was black, fix the tree
    if (originalColor == Color::BLACK) {
        if (fixupNode == nullptr) {
            // Use Nil as temporary node
            Nil->parent = del->parent;
            fixupNode = Nil;
            removeFixup(fixupNode);
            dieConnectNil();
        } else {
            removeFixup(fixupNode);
        }
    }

    delete del;
}

public:
  // 构造函数
  RedBlackTree() : root(nullptr), size(0), Nil(new Node()) {
    Nil->color = Color::BLACK;
  }

  // 插入
  void insert(const Key &key, const Value &value) { insertNode(key, value); }

  // 删除
  void remove(const Key &key) {
    Node *nodeToBeRemoved = lookUp(key);
    if (nodeToBeRemoved != nullptr) {
      deleteNode(nodeToBeRemoved);
      size--;
    }
  }

  Value *at(const Key &key) {
    auto ans = lookUp(key);
    if (ans != nullptr) {
      return &ans->value;
    }
    return nullptr;
  }

  int getSize() { return size; }

  bool empty() { return size == 0; }

  // 中序遍历打印
  void print() {
    inorderTraversal(root);
    std::cout << std::endl;
  }

  void clear() {
    deleteNode(root);
    size = 0;
  }

  // 析构函数
  ~RedBlackTree() {
    // 释放节点内存
    deleteTree(root);
  }

private:
  // 递归释放节点内存
  void deleteTree(Node *node) {
    if (node) {
      deleteTree(node->left);
      deleteTree(node->right);
      delete node;
    }
  }
};

int main() {
      // 创建红黑树实例
    RedBlackTree<int, int> rbTree;

    int N;
    std::cin >> N;
    getchar();

    std::string line;
    for (int i = 0; i < N; i++)
    {
      std::getline(std::cin, line);
      std::istringstream iss(line);
      std::string command;
      iss >> command;

      int key;
      int value;

      if (command == "insert")
      {
          iss >> key >> value;
          rbTree.insert(key, value);
      }

      if (command == "size")
      {
          std::cout << rbTree.getSize() << std::endl;
      }

      if (command == "at")
      {
          iss >> key;
          int *res = rbTree.at(key);
          if (res == nullptr)
          {
              std::cout << "not exist" << std::endl;
          }
          else
          {
              std::cout << *res << std::endl;
          }
      }

      if (command == "remove")
      {
          iss >> key;
          rbTree.remove(key);
      }

      if (command == "print")
      {
          if (rbTree.empty())
          {
              std::cout << "empty" << std::endl;
          }
          else
          {
              rbTree.print();
          }
      }
    }
    return 0;
}
```

```cpp
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

enum class Color { BLACK, RED };

template <class Key, class Value>
class RBTree {
    class RBNode {
    public:
        RBNode* left;
        RBNode* right;
        RBNode* parent;
        Key key;
        Value value;
        Color color;
        RBNode(const Key& key, const Value& value)
            : key(key), value(value), color(Color::RED),
              parent(nullptr), left(nullptr), right(nullptr) {
        }
        RBNode()
            : color(Color::BLACK), parent(nullptr), left(nullptr), right(nullptr) {
        }
    };
private:
    RBNode* nil;
    RBNode* root;
    size_t size;

    void leftRotate(RBNode* x) {
        RBNode* y = x->right;
        x->right = y->left;
        if (y->left != nil)
            y->left->parent = x;
        y->parent = x->parent;
        if (x->parent == nil) {
            root = y;
        } else if (x == x->parent->left) {
            x->parent->left = y;
        } else {
            x->parent->right = y;
        }
        y->left = x;
        x->parent = y;
    }

    void rightRotate(RBNode* y) {
        RBNode* x = y->left;
        y->left = x->right;
        if (x->right != nil)
            x->right->parent = y;
        x->parent = y->parent;
        if (y->parent == nil) {
            root = x;
        } else if (y == y->parent->left) {
            y->parent->left = x;
        } else {
            y->parent->right = x;
        }
        x->right = y;
        y->parent = x;
    }

    RBNode* searchRBNode(const Key& key) {
        RBNode* cur = root;
        while (cur != nil) {
            if (key < cur->key)
                cur = cur->left;
            else if (key > cur->key)
                cur = cur->right;
            else
                return cur;
        }
        return nil;
    }

    RBNode* minimum(RBNode* node) {
        while (node->left != nil)
            node = node->left;
        return node;
    }

    void transPlant(RBNode* u, RBNode* v) {
        if (u->parent == nil) {
            root = v;
        } else if (u == u->parent->left) {
            u->parent->left = v;
        } else {
            u->parent->right = v;
        }
        v->parent = u->parent;
    }

    void deleteFixup(RBNode* x) {
        while (x != root && x->color == Color::BLACK) {
            if (x == x->parent->left) {
                RBNode* w = x->parent->right;
                if (w->color == Color::RED) {
                    w->color = Color::BLACK;
                    x->parent->color = Color::RED;
                    leftRotate(x->parent);
                    w = x->parent->right;
                }
                if (w->left->color == Color::BLACK && w->right->color == Color::BLACK) {
                    w->color = Color::RED;
                    x = x->parent;
                } else {
                    if (w->right->color == Color::BLACK) {
                        w->left->color = Color::BLACK;
                        w->color = Color::RED;
                        rightRotate(w);
                        w = x->parent->right;
                    }
                    w->color = x->parent->color;
                    x->parent->color = Color::BLACK;
                    w->right->color = Color::BLACK;
                    leftRotate(x->parent);
                    x = root;
                }
            } else {
                RBNode* w = x->parent->left;
                if (w->color == Color::RED) {
                    w->color = Color::BLACK;
                    x->parent->color = Color::RED;
                    rightRotate(x->parent);
                    w = x->parent->left;
                }
                if (w->right->color == Color::BLACK && w->left->color == Color::BLACK) {
                    w->color = Color::RED;
                    x = x->parent;
                } else {
                    if (w->left->color == Color::BLACK) {
                        w->right->color = Color::BLACK;
                        w->color = Color::RED;
                        leftRotate(w);
                        w = x->parent->left;
                    }
                    w->color = x->parent->color;
                    x->parent->color = Color::BLACK;
                    w->left->color = Color::BLACK;
                    rightRotate(x->parent);
                    x = root;
                }
            }
        }
        x->color = Color::BLACK;
    }

    void deleteNode(RBNode* z) {
        RBNode* y = z;
        RBNode* x;
        Color y_original_color = y->color;
        if (z->left == nil) {
            x = z->right;
            transPlant(z, z->right);
        } else if (z->right == nil) {
            x = z->left;
            transPlant(z, z->left);
        } else {
            y = minimum(z->right);
            y_original_color = y->color;
            x = y->right;
            if (y->parent == z) {
                x->parent = y;
            } else {
                transPlant(y, y->right);
                y->right = z->right;
                y->right->parent = y;
            }
            transPlant(z, y);
            y->left = z->left;
            y->left->parent = y;
            y->color = z->color;
        }
        if (y_original_color == Color::BLACK) {
            deleteFixup(x);
        }
        delete z;
        size--;
    }

    void destroy(RBNode* node) {
        if (node != nil) {
            destroy(node->left);
            destroy(node->right);
            delete node;
        }
    }

    void inorderPrint(RBNode* node) {
        if (node != nil) {
            inorderPrint(node->left);
            cout << node->key << " " << node->value << " ";
            inorderPrint(node->right);
        }
    }

    void insertFixup(RBNode* node) {
        while (node->parent->color == Color::RED) {
            if (node->parent == node->parent->parent->left) {
                RBNode* uncle = node->parent->parent->right;
                if (uncle->color == Color::RED) {
                    node->parent->color = Color::BLACK;
                    uncle->color = Color::BLACK;
                    node->parent->parent->color = Color::RED;
                    node = node->parent->parent;
                } else {
                    if (node == node->parent->right) {
                        node = node->parent;
                        leftRotate(node);
                    }
                    node->parent->color = Color::BLACK;
                    node->parent->parent->color = Color::RED;
                    rightRotate(node->parent->parent);
                }
            } else {
                RBNode* uncle = node->parent->parent->left;
                if (uncle->color == Color::RED) {
                    node->parent->color = Color::BLACK;
                    uncle->color = Color::BLACK;
                    node->parent->parent->color = Color::RED;
                    node = node->parent->parent;
                } else {
                    if (node == node->parent->left) {
                        node = node->parent;
                        rightRotate(node);
                    }
                    node->parent->color = Color::BLACK;
                    node->parent->parent->color = Color::RED;
                    leftRotate(node->parent->parent);
                }
            }
        }
        root->color = Color::BLACK;
    }

    void insertRBNode(const Key& key, const Value& value) {
        RBNode* node = new RBNode(key, value);
        node->parent = nil;
        node->left = nil;
        node->right = nil;
        RBNode* pre = nil;
        RBNode* cur = root;
        while (cur != nil) {
            pre = cur;
            if (key < cur->key) {
                cur = cur->left;
            } else if (key > cur->key) {
                cur = cur->right;
            } else {
                delete node;
                return;
            }
        }
        node->parent = pre;
        if (pre == nil) {
            root = node;
        } else if (key < pre->key) {
            pre->left = node;
        } else {
            pre->right = node;
        }
        ++size;
        insertFixup(node);
    }

    void deleteRBTree(const Key& key) {
        RBNode* node = searchRBNode(key);
        if (node == nil) return;
        deleteNode(node);
    }

public:
    RBTree() : nil(new RBNode()), root(nil), size(0) {
        nil->left = nil;
        nil->right = nil;
        nil->parent = nil;
        nil->color = Color::BLACK;
    }
    ~RBTree() {
        destroy(root);
        delete nil;
    }

    void print() {
        if (root == nil) {
            cout << "empty" << endl;
            return;
        }
        inorderPrint(root);
        cout << endl;
    }

    Value* at(const Key& key) {
        RBNode* node = searchRBNode(key);
        if (node == nil) {
            return nullptr;
        }
        return &node->value;
    }

    size_t getSize() const {
        return size;
    }

    bool empty() {
        return size == 0;
    }

    void insert(const Key& key, const Value& value) {
        insertRBNode(key, value);
    }

    void remove(const Key& key) {
        deleteRBTree(key);
    }

    void clear() {
        if (root != nil) {
            destroy(root);
        }
        root = nil;
        size = 0;
    }
};

int main() {
    RBTree<int, int> rbTree;
    int N;
    cin >> N;
    string line;
    getline(cin, line); // consume newline

    int key, value;

    for (int i = 0; i < N; i++) {
        getline(cin, line);
        istringstream iss(line);
        string command;
        iss >> command;

        if (command == "insert") {
            iss >> key >> value;
            rbTree.insert(key, value);
        } else if (command == "size") {
            cout << rbTree.getSize() << endl;
        } else if (command == "at") {
            iss >> key;
            int* res = rbTree.at(key);
            if (res == nullptr) {
                cout << "not exist" << endl;
            } else {
                cout << *res << endl;
            }
        } else if (command == "remove") {
            iss >> key;
            rbTree.remove(key);
        } else if (command == "print") {
            if (rbTree.empty()) {
                cout << "empty" << endl;
            } else {
                rbTree.print();
            }
        }
    }
}
```

三、常见问题
------

### 1、为什么红黑树的操作是对数时间复杂度的？

*   ①：因为红黑树的性质。
*   ②：树的高度始终保持在对数级别，所有的操作都要在从根到叶子的路径上进行。

### 2、如何验证一个二叉树是不是红黑树？

*   依然是看二叉树是否满足红黑树性质

### 3、为什么红黑树不是完全平衡的二叉树？

*   平衡二叉树要求二叉树的每个节点的左右子树高度差最多为一。
*   但是红黑树不用这样，而是一个近似平衡的二叉树。

本文转自 <https://blog.csdn.net/2401_82911768/article/details/147426122?sharetype=blogdetail&sharerId=147426122&sharerefer=PC&sharesource=2401_82911768&spm=1011.2480.3001.8118>，如有侵权，请联系删除。