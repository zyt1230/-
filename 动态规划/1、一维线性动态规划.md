做题的步骤-----经验

1、确定状态：找到**状态数组**（可以尝试用一句话来描述问题，其中涉及到的参数是状态数组的下标）

2、确定**状态方程**。找到第i个状态，默认为前面1~i-1已经求出

3、**初始化状态数组**：即找到初始状态。

4、写**状态转移部分代码**。

5、输出题目要求的状态（大部分是最终状态）

注意：一般选用  1到 i-1 。因为 dp[ i ]获得 dp[ i-1 ]的值就比较简单了。

![3971134f-738b-496d-af60-1d450e5dbf9b](file:///C:/Users/LEGION/Pictures/3971134f-738b-496d-af60-1d450e5dbf9b.png)

![770e4625-4de5-4533-a108-ee9a68289fc4](file:///C:/Users/LEGION/Pictures/770e4625-4de5-4533-a108-ee9a68289fc4.png)
最长上升子序列
=======

是指从原序列中**按顺序**取出一些数字排在一起，这些数字是**逐渐增大**的。

[B3637 最长上升子序列 - 洛谷]((https://www.luogu.com.cn/problem/B3637))

这段代码实现了**最长递增子序列（LIS）**问题的动态规划解法。以下是加了注释的代码：

```cpp
#include <iostream>
#include <algorithm> // 用于 max 函数
using namespace std;

const int N = 100010; // 定义数组的最大长度

int n;       // 数组的长度
int a[N];    // 存储输入的数组
int dp[N];   // dp[i] 表示以 a[i] 结尾的最长递增子序列的长度
int ans = 0; // 存储最终的结果

int main() {
    // 输入数组的长度
    scanf("%d", &n);

    // 输入数组元素，并初始化 dp 数组
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        dp[i] = 1; // 每个元素本身构成一个长度为 1 的递增子序列
    }

    // 动态规划求解最长递增子序列
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i - 1; j++) {
            // 如果 a[i] 大于 a[j]，说明可以将 a[i] 接在以 a[j] 结尾的递增子序列后面
            if (a[i] > a[j]) {
                dp[i] = max(dp[i], dp[j] + 1); // 更新 dp[i]
            }
        }
    }

    // 遍历 dp 数组，找到最大值
    for (int i = 1; i <= n; i++) {
        ans = max(ans, dp[i]);
    }

    // 输出结果
    printf("%d\n", ans);

    return 0;
}
```

---

### 代码逻辑说明：

#### 1. **输入部分**：

- 输入数组的长度 `n`。
- 输入数组元素 `a[1]` 到 `a[n]`。
- 初始化 `dp` 数组，`dp[i] = 1`，表示每个元素本身构成一个长度为 1 的递增子序列。

#### 2. **动态规划求解**：

- 使用双重循环：
  - 外层循环遍历数组中的每个元素 `a[i]`。
  - 内层循环遍历 `a[1]` 到 `a[i-1]`，检查是否可以将 `a[i]` 接在以 `a[j]` 结尾的递增子序列后面。
  - 如果 `a[i] > a[j]`，则更新 `dp[i] = max(dp[i], dp[j] + 1)`。

#### 3. **结果计算**：

- 遍历 `dp` 数组，找到最大值 `ans`，即最长递增子序列的长度。

#### 4. **输出结果**：

- 输出 `ans`。

---

### 示例运行：

#### 输入：

```
6
3 1 4 1 5 9
```

#### 执行过程：

1. 初始化：
   - `a = [3, 1, 4, 1, 5, 9]`
   - `dp = [1, 1, 1, 1, 1, 1]`
2. 动态规划：
   - `i = 2`：
     - `j = 1`：`a[2] = 1 < a[1] = 3`，不更新。
     - `dp = [1, 1, 1, 1, 1, 1]`
   - `i = 3`：
     - `j = 1`：`a[3] = 4 > a[1] = 3`，`dp[3] = max(1, 1 + 1) = 2`
     - `j = 2`：`a[3] = 4 > a[2] = 1`，`dp[3] = max(2, 1 + 1) = 2`
     - `dp = [1, 1, 2, 1, 1, 1]`
   - `i = 4`：
     - `j = 1`：`a[4] = 1 < a[1] = 3`，不更新。
     - `j = 2`：`a[4] = 1 == a[2] = 1`，不更新。
     - `j = 3`：`a[4] = 1 < a[3] = 4`，不更新。
     - `dp = [1, 1, 2, 1, 1, 1]`
   - `i = 5`：
     - `j = 1`：`a[5] = 5 > a[1] = 3`，`dp[5] = max(1, 1 + 1) = 2`
     - `j = 2`：`a[5] = 5 > a[2] = 1`，`dp[5] = max(2, 1 + 1) = 2`
     - `j = 3`：`a[5] = 5 > a[3] = 4`，`dp[5] = max(2, 2 + 1) = 3`
     - `j = 4`：`a[5] = 5 > a[4] = 1`，`dp[5] = max(3, 1 + 1) = 3`
     - `dp = [1, 1, 2, 1, 3, 1]`
   - `i = 6`：
     - `j = 1`：`a[6] = 9 > a[1] = 3`，`dp[6] = max(1, 1 + 1) = 2`
     - `j = 2`：`a[6] = 9 > a[2] = 1`，`dp[6] = max(2, 1 + 1) = 2`
     - `j = 3`：`a[6] = 9 > a[3] = 4`，`dp[6] = max(2, 2 + 1) = 3`
     - `j = 4`：`a[6] = 9 > a[4] = 1`，`dp[6] = max(3, 1 + 1) = 3`
     - `j = 5`：`a[6] = 9 > a[5] = 5`，`dp[6] = max(3, 3 + 1) = 4`
     - `dp = [1, 1, 2, 1, 3, 4]`
3. 结果计算：
   - `ans = max(dp[1], dp[2], dp[3], dp[4], dp[5], dp[6]) = 4`

#### 输出：

```
4
```

---

### 时间复杂度：

- **O(n^2)**，其中 `n` 是数组的长度。双重循环的时间复杂度为 O(n^2)。

---

### 空间复杂度：

- **O(n)**，使用了 `dp` 数组存储中间结果。

---

### 总结：

- 这段代码通过动态规划解决了最长递增子序列问题，时间复杂度为 O(n^2)，空间复杂度为 O(n)。
- 通过注释和格式化，代码更易读且逻辑清晰。


