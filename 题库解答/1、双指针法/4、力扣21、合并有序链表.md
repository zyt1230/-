- 分离指针
  [力扣21、合并2个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 创建一个虚拟头节点，值为 -1
        ListNode* list3 = new ListNode(-1);

        // cur 指针指向虚拟头节点，用于构建新链表
        ListNode* cur = list3;

        // 遍历两个链表，直到其中一个链表为空
        while (list1 != nullptr && list2 != nullptr) {
            // 比较两个链表当前节点的值
            if (list1->val < list2->val) {
                // 如果 list1 的值较小，将 list1 的当前节点接入新链表
                cur->next = list1;
                list1 = list1->next; // list1 指针后移
            } else {
                // 如果 list2 的值较小，将 list2 的当前节点接入新链表
                cur->next = list2;
                list2 = list2->next; // list2 指针后移
            }
            // cur 指针后移，指向新链表的最后一个节点
            cur = cur->next;
        }

        // 合并后，list1 和 list2 中最多只有一个链表还未被合并完
        // 将新链表的末尾指向未合并完的链表
        cur->next = (list1 != nullptr) ? list1 : list2;

        // 返回合并后的链表（跳过虚拟头节点）
        return list3->next;
    }
};3->next;
    }
};
```

### **代码讲解**

1. **虚拟头节点**：
   
   * 创建一个虚拟头节点 `list3`，其值为 `-1`。
   
   * 使用虚拟头节点的目的是简化链表操作，避免处理空链表的特殊情况。

2. **指针初始化**：
   
   * `cur` 指针初始指向虚拟头节点，用于构建新链表。

3. **遍历链表**：
   
   * 使用 `while` 循环遍历两个链表 `list1` 和 `list2`，直到其中一个链表为空。
   
   * 在每次循环中，比较 `list1` 和 `list2` 当前节点的值：
     
     * 如果 `list1->val < list2->val`，将 `list1` 的当前节点接入新链表，并将 `list1` 指针后移。
     
     * 否则，将 `list2` 的当前节点接入新链表，并将 `list2` 指针后移。
   
   * 每次操作后，将 `cur` 指针后移，指向新链表的最后一个节点。

4. **处理剩余节点**：
   
   * 当其中一个链表遍历完后，另一个链表可能还有剩余节点。
   
   * 将新链表的末尾指向未合并完的链表。

5. **返回结果**：
   
   * 返回 `list3->next`，即合并后的链表（跳过虚拟头节点）。

---

### **示例**

#### **输入**

```cpp
list1: 1 -> 3 -> 5
list2: 2 -> 4 -> 6
```

#### **执行过程**

1. 初始化：
   
   * `list3 -> (-1)`
   
   * `cur` 指向 `list3`。

2. 遍历链表：
   
   * 比较 `1` 和 `2`，`1` 较小，将 `1` 接入新链表：
     
     * `list3 -> (-1) -> 1`
     
     * `cur` 指向 `1`，`list1` 指向 `3`。
   
   * 比较 `3` 和 `2`，`2` 较小，将 `2` 接入新链表：
     
     * `list3 -> (-1) -> 1 -> 2`
     
     * `cur` 指向 `2`，`list2` 指向 `4`。
   
   * 比较 `3` 和 `4`，`3` 较小，将 `3` 接入新链表：
     
     * `list3 -> (-1) -> 1 -> 2 -> 3`
     
     * `cur` 指向 `3`，`list1` 指向 `5`。
   
   * 比较 `5` 和 `4`，`4` 较小，将 `4` 接入新链表：
     
     * `list3 -> (-1) -> 1 -> 2 -> 3 -> 4`
     
     * `cur` 指向 `4`，`list2` 指向 `6`。
   
   * 比较 `5` 和 `6`，`5` 较小，将 `5` 接入新链表：
     
     * `list3 -> (-1) -> 1 -> 2 -> 3 -> 4 -> 5`
     
     * `cur` 指向 `5`，`list1` 指向 `nullptr`。

3. 处理剩余节点：
   
   * `list1` 为空，将新链表的末尾指向 `list2` 的剩余部分：
     
     * `list3 -> (-1) -> 1 -> 2 -> 3 -> 4 -> 5 -> 6`

4. 返回结果：
   
   * 返回 `list3->next`，即 `1 -> 2 -> 3 -> 4 -> 5 -> 6`。

#### **输出**

```cpp
1 -> 2 -> 3 -> 4 -> 5 -> 6
```


